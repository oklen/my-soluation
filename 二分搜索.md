### 3.2二分搜索
===
二分搜索法,是通过不断缩小解可能存在的范围,从而得到问题最优解的方法.
#### 从有序数组查找某个值
---
#### 假定一个解并判断是否可行 最大化最小值等等
如果在求解最大化或最小化问题中,能够比较简单地判断条件是否满足,那么使用二分搜索法就可以很好的解决问题
**当设计浮点数时,如果EPS过小可能导致无限循环!**
---
#### 最大化平均值
**重要!**
有n个物品的重量和价值分别是wi和vi.从中选出k个物品使得单位重量的价值最大.
```
C(x)=二分变量,最小单位重量不小于x.
result = Sum(vi)/Sum(wi)
Sum(vi)/Sum(wi)>=x => Sum(vi-x*wi)>=0
此时进行贪心的排序即可,看最后结果是否大于0
```
每次判断的复杂度是O(nlogn)
---
### 常用技巧
#### 尺取法
就是一段段的推进
#### 反转(开关问题)
这种问题是给定一个初始状态,然后求到底一个目标状态.而且其中的操作具有互逆性.其中的难点一个是在解集非常大,这时往往要想办法缩小解集,比如先罗列一个小范围解集,其后的解都可按一定规律直接求出,这样复杂度就减小了.
#### 弹性碰撞
这个是想法找到规律,一种等效的规律,即可简化计算.注意看能不能用简单地方法解决复杂的计数问题.(转化或者说是寻找规律,按理来说这个是需要记录碰撞的,然而直接对高度排序就能解决这个问题)
#### 折半枚举(双向搜索**
1. 一种想办法log2的枚举办法,准确来说分而治之
2. 先枚举一半,另一半可根据给出条件确定.这样复杂度就减小了.
#### 坐标离散化
这里用到的技巧是,在坐标两边+-1,然后排序去重.然后再根据原来坐标点找回坐标.
3.3活用各种数据结构
===
#### 线段树
主要用在RMQ等,有快速值更新和范围查询的能力
RMQ还可以用稀疏表(Sparse Table)查询是常数级,但是预处理(O(nlogn))和更新都比较慢
#### 树状数组(Binary Index Tree)
给一个初始值全为0的数列a1,a2,...,an
- 给定i,计算a1+a2+..+ai
- 给定i和x,执行ai+=x
1.基于线段树实现,记录最小值改为和即可
2.BIT的结构
BIT结构还比较容易扩展到二维.一维的每个元素变到二维即可.
例子:冒泡排序的交换次数.p179
更加复杂的线段树和树状数组能实现范围加,范围求和
  这里用线段树的话要增加一个变量记录该范围内每个元素delta值反应完全覆盖这个区间的操作,另一个是整体的delta值,这个值通常用来反映与这个区间部分重叠的范围操作.
  如果采用树状数组,需要定义两个数组bit0,bit1,并且设sum(ai) = sum(bit1,i)*i+sum(bit0,i)
这样在[l,r]区间上加上s就可以看成是
- 在bit0的l位置上-x(l-1)
- 在bit1的l位置上加x
- 在bit0的r+1位置上加xr
- 在bit1的r+1位置上加-x
这样查询和更新操作都可以在O(logn)时间里完成
分桶法和平方切割
-
*分桶法(bucket method)*是把一排物品或者平面分成桶,每个桶分别维护自己内部的信息,以达到高效计算的目的.
其中,*平方分割(sqrt decomposition)*是把排成一排物品的n个元素每sqrt(n)个分在一个桶内进行维护方法的统称.这样的分割方法可以使对区间的操作的复杂度降至O(sqrt(n))
*区域树(Range Tree)*
每个节点维护一个数组的线段树和每个节点维护一棵树的线段树也叫区域树(Range Tree).

如果把数列ai考虑成平面上(i,ai)的点列,那么上面问题中的查询
* 计算区间[1,r)中不超过v的数的个数
就可以看成是
* 计算满足1<=x<r,y<=v的点的个数
这样的查询.Range Tree适合对矩形的区域进行处理.并且,和树状数组一样,通过多重嵌套的线段树也可以实现高维度的Range Tree. *可以实现区域检索,非常有用*
3.4熟练掌握动态规划
-
#### 状态压缩DP
旅行商问题,铺砖问题(在图论中叫做完美匹配,实际上,可以在多项式时间内求解)
#### 矩阵的幕
用来快速计算一个递推式的第n项.
也可以快速求出矩阵的幕和(poj3233)
#### 利用数据结构高效求解
如果一个DP的转移方程要从一个范围中去前面的最小值,这时就可以利用线段树的RMQ,大大缩短时间复杂度
3.5借助水流解决问题的网络流
-
#### 最大流
使用Ford-Fulkerson算法
(1)只利用满足f(e)<c(e)的e或者满足f(e)>0的e对应的反向边rev(e),寻找一条s到t的路径.
(2)如果不存在满足条件的路径,则结束.否则,沿着该路径尽可能的地增加流,返回第(1)步.
这里实际上是对简单贪心做了一个修正,使其适当的在各个路径上分配流.
残余网络:f(e)<c(e)的e和满足f(e)>0的e对应的反向边rev(e)所组成的图.其上的s-t路径称为**增广路**.

